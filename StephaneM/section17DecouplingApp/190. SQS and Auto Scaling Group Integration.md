# ğŸŒŸ SQS + Auto Scaling Group(ASG) ì—°ë™ì´ ë­”ë°?

**í•µì‹¬ ìš”ì•½:**
â€œì¼ì„ ì²˜ë¦¬í•˜ëŠ” ì†ë„ê°€ ëŠë ¤ì ¸ì„œ í•  ì¼ì´ ìŒ“ì´ë©´, ì¼ê¾¼(EC2)ì„ ìë™ìœ¼ë¡œ ë” ë¶ˆëŸ¬ì˜¤ëŠ” ì‹œìŠ¤í…œ.â€

---

# ğŸ­ ë¹„ìœ ë¡œ ì´í•´í•´ë³´ì:

### â€œSQS = ëŒ€ê¸°ì—´(ì‘ì—…í•¨), ASG = ì¼ê¾¼íŒ€(EC2), CloudWatch = ê°ë…ê´€â€

* ê³ ê° ì£¼ë¬¸ì´ ë§‰ ë“¤ì–´ì˜´ â†’ SQSì— ìŒ“ì„
* EC2ë“¤ì€ SQSì—ì„œ ì‘ì—… í•˜ë‚˜ì”© êº¼ë‚´ ì²˜ë¦¬
* ì‘ì—…ì´ ë„ˆë¬´ ë§ì´ ìŒ“ì—¬ìˆìœ¼ë©´?
  â†’ **ê°ë…(CloudWatch)** ì´ ë³´ê³  â€œì¼ê¾¼ ë¶€ì¡±!â€
  â†’ **ASGê°€ ìë™ìœ¼ë¡œ EC2ë¥¼ ë” ë½‘ì•„ì˜´**
* ì‘ì—…ì´ ì ìœ¼ë©´ â†’ EC2ë¥¼ ìë™ìœ¼ë¡œ ì¤„ì„

---

# ğŸ“ˆ ì™œ ì´ê²Œ ì¤‘ìš”í•´?

ê°‘ìê¸° ì£¼ë¬¸/ìš”ì²­ì´ í­ì£¼í•˜ë©´ ì„œë²„ë‚˜ DBê°€ ë²„í‹°ì§€ ëª»í•˜ê³  ë‹¤ìš´ë  ìˆ˜ ìˆìŒ.
**SQSë¥¼ ì¤‘ê°„ì— ë‘ë©´ â€œë²„í¼ ì—­í• â€** ì„ í•´ì„œ ì ˆëŒ€ ìš”ì²­ì´ ì‚¬ë¼ì§€ì§€ ì•ŠìŒ.

---

# ğŸ”µ êµ¬ì¡°ë¥¼ ì•„ì£¼ ê°„ë‹¨í•˜ê²Œ ì •ë¦¬í•˜ë©´:

### 1) **ì• í”Œë¦¬ì¼€ì´ì…˜ â†’ SQS**

DBì— ì§ì ‘ ì“°ì§€ ì•Šê³  ë©”ì‹œì§€(SQS)ì— ë¨¼ì € ë„£ìŒ.
â†’ ì•ˆì „í•˜ê²Œ ì €ì¥ë¨ (SQSëŠ” ì‚¬ì‹¤ìƒ ë¬´í•œ í™•ì¥ë¨)

### 2) **ASGì˜ EC2ë“¤ì´ SQSì—ì„œ ë©”ì‹œì§€ êº¼ëƒ„**

* í•˜ë‚˜ì”© êº¼ë‚´ì„œ DBì— ì €ì¥
* ì„±ê³µí•˜ë©´ SQSì—ì„œ ë©”ì‹œì§€ ì‚­ì œ

### 3) **íê°€ ë„ˆë¬´ ê¸¸ì–´ì§€ë©´ â†’ ìë™ìœ¼ë¡œ EC2 ì¦ê°€**

CloudWatch metric(ApproximateNumberOfMessages)ì„ ê¸°ì¤€ìœ¼ë¡œ ì…‹ì—….

ì˜ˆ: ë©”ì‹œì§€ê°€ 1,000ê°œ ìŒ“ì´ë©´ â†’ 10ëŒ€ ë” ëŠ˜ë ¤ë¼

### 4) **íê°€ ì§§ì•„ì§€ë©´ â†’ EC2 ì¤„ì–´ë“¦**

---

# âš¡ ì‹¤ì „ íŒ¨í„´ ì˜ˆì‹œ

## ğŸ›’ 1) ëŒ€ê·œëª¨ ì‡¼í•‘ ìº í˜ì¸ (íŠ¸ë˜í”½ í­ì£¼)

ì‚¬ìš©ìê°€ ì£¼ë¬¸ â†’ ëŒ€ëŸ‰ íŠ¸ë˜í”½ ë°œìƒ
DBë¡œ ë°”ë¡œ ì“°ë©´ DB overload â†’ ì‹¤íŒ¨ ë°œìƒ

â¡ **í•´ê²°:**
DBì— ë°”ë¡œ ì“°ì§€ ë§ê³  SQSì— ë¨¼ì € ë„£ìŒ
â†’ ë°±ì—”ë“œì—ì„œ ì²œì²œíˆ DBì— ì•ˆì „í•˜ê²Œ ì €ì¥
â†’ ì ˆëŒ€ ê±°ë˜ ëˆ„ë½ ì—†ìŒ

---

## ğŸ—‚ 2) ì• í”Œë¦¬ì¼€ì´ì…˜ ê³„ì¸µ ë¶„ë¦¬ (Decoupling)

ì˜ˆì „ ë°©ì‹:
í”„ë¡ íŠ¸ â†’ ìš”ì²­ ì²˜ë¦¬ â†’ ë°±ì—”ë“œ â†’ DB (ì¦‰ì‹œ ì²˜ë¦¬ í•„ìš”)

ë¬¸ì œ:
ë°±ì—”ë“œê°€ ëŠë ¤ì§€ë©´ ì „ì²´ ì‹œìŠ¤í…œì´ ëŠë ¤ì§

â¡ **SQSë¥¼ ë„£ìœ¼ë©´:**
í”„ë¡ íŠ¸ â†’ ë©”ì‹œì§€ë§Œ ë„£ê³  ë°”ë¡œ ì‘ë‹µ ê°€ëŠ¥
ë°±ì—”ë“œëŠ” ë‚˜ì¤‘ì— ìê¸° ì†ë„ëŒ€ë¡œ ì²˜ë¦¬
â†’ ì„œë¹„ìŠ¤ ì•ˆì •ì„± í­ì¦

---

# ğŸ§© ëª¨ë“  ê°œë…ì„ 10ì´ˆì— ì •ë¦¬í•˜ë©´?

* SQSëŠ” **í•  ì¼ì´ ìŒ“ì´ëŠ” ìƒì**
* EC2ëŠ” **ì¼ê¾¼**
* ASGëŠ” **ì¼ê¾¼ì„ ìë™ìœ¼ë¡œ ëŠ˜ë¦¬ê³  ì¤„ì´ëŠ” íŒ€ì¥**
* CloudWatchëŠ” **ì¼ê°ì´ ì–¼ë§ˆë‚˜ ìŒ“ì˜€ëŠ”ì§€ ê°ì‹œ**
* DBê°€ ë²„ê±°ìš¸ ë•Œë„ SQSê°€ **ì™„ì¶© ì—­í• ** í•´ì¤˜ì„œ ì„œë¹„ìŠ¤ê°€ ì•ˆì „í•´ì§
* í”„ë¡ íŠ¸/ë°±ì—”ë“œ **ì™„ì „ ë¶„ë¦¬(Decoupling)** ë„ ê°€ëŠ¥

---

ì›í•œë‹¤ë©´

* ì•„í‚¤í…ì²˜ ê·¸ë¦¼(í…ìŠ¤íŠ¸ ê¸°ë°˜)
* ì‹¤ì œ AWS ì„¤ì • ì˜ˆì‹œ
* ì‹œí—˜ì— ìì£¼ ë‚˜ì˜¤ëŠ” í•¨ì • í¬ì¸íŠ¸ ì •ë¦¬
  ë„ ë§Œë“¤ì–´ì¤„ê²Œ!


# SQS and Auto Scaling Group Integration  
# SQSì™€ ì˜¤í†  ìŠ¤ì¼€ì¼ë§ ê·¸ë£¹ í†µí•©  

---

## Introduction to SQS and Auto Scaling Groups  
## SQSì™€ ì˜¤í†  ìŠ¤ì¼€ì¼ë§ ê·¸ë£¹ ì†Œê°œ  

We can use the SQS queue in conjunction with Auto Scaling Groups (ASG).  
SQS íë¥¼ ì˜¤í†  ìŠ¤ì¼€ì¼ë§ ê·¸ë£¹(ASG)ê³¼ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

This integration opens up several useful patterns.  
ì´ í†µí•©ì€ ì—¬ëŸ¬ ê°€ì§€ ìœ ìš©í•œ íŒ¨í„´ì„ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.  

Essentially, we have an SQS queue and an Auto Scaling Group.  
ê¸°ë³¸ì ìœ¼ë¡œ ìš°ë¦¬ëŠ” SQS íì™€ ì˜¤í†  ìŠ¤ì¼€ì¼ë§ ê·¸ë£¹ì„ ê°–ê²Œ ë©ë‹ˆë‹¤.  

The EC2 instances within the ASG poll for messages from the SQS queue.  
ASG ë‚´ì˜ EC2 ì¸ìŠ¤í„´ìŠ¤ê°€ SQS íì—ì„œ ë©”ì‹œì§€ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.  

The main idea is to scale the Auto Scaling Group automatically based on the size of the queue.  
í•µì‹¬ ê°œë…ì€ íì˜ í¬ê¸°ì— ë”°ë¼ ì˜¤í†  ìŠ¤ì¼€ì¼ë§ ê·¸ë£¹ì„ ìë™ìœ¼ë¡œ í™•ì¥ ë˜ëŠ” ì¶•ì†Œí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.  

We monitor the CloudWatch metric called the approximate number of messages, which represents how many messages remain in the queue.  
ìš°ë¦¬ëŠ” CloudWatch ì§€í‘œì¸ **ApproximateNumberOfMessages**(ëŒ€ëµì ì¸ ë©”ì‹œì§€ ìˆ˜)ë¥¼ ëª¨ë‹ˆí„°ë§í•˜ëŠ”ë°, ì´ëŠ” íì— ë‚¨ì•„ ìˆëŠ” ë©”ì‹œì§€ ê°œìˆ˜ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.  

You can set an alarm such that if this metric exceeds a thresholdâ€”for example, 1,000 messagesâ€”this indicates a backlog in processing.  
ì´ ì§€í‘œê°€ ì„ê³„ê°’(ì˜ˆ: 1,000ê°œ ë©”ì‹œì§€)ì„ ì´ˆê³¼í•˜ë©´ ì²˜ë¦¬ ì§€ì—°ì´ ë°œìƒí–ˆìŒì„ ì•Œë¦¬ëŠ” ì•ŒëŒì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

When the alarm triggers, it initiates a scaling action in your Auto Scaling Group.  
ì•ŒëŒì´ íŠ¸ë¦¬ê±°ë˜ë©´ ì˜¤í†  ìŠ¤ì¼€ì¼ë§ ê·¸ë£¹ì—ì„œ ìŠ¤ì¼€ì¼ë§ ì‘ì—…ì´ ì‹œì‘ë©ë‹ˆë‹¤.  

This means more EC2 instances will be added to the group to handle the increased load.  
ì¦‰, ì¦ê°€í•œ ë¶€í•˜ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ë” ë§ì€ EC2 ì¸ìŠ¤í„´ìŠ¤ê°€ ê·¸ë£¹ì— ì¶”ê°€ë©ë‹ˆë‹¤.  

As a result, messages will be processed faster, reducing the queue size.  
ê·¸ ê²°ê³¼ ë©”ì‹œì§€ê°€ ë” ë¹ ë¥´ê²Œ ì²˜ë¦¬ë˜ì–´ í í¬ê¸°ê°€ ì¤„ì–´ë“­ë‹ˆë‹¤.  

This scaling works both ways: you can scale up or scale down based on the queue length.  
ì´ ìŠ¤ì¼€ì¼ë§ì€ ì–‘ë°©í–¥ìœ¼ë¡œ ì‘ë™í•˜ì—¬ í ê¸¸ì´ì— ë”°ë¼ í™•ì¥(Scale up) ë˜ëŠ” ì¶•ì†Œ(Scale down)ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.  

---

## Patterns Enabled by SQS and Auto Scaling  
## SQSì™€ ì˜¤í†  ìŠ¤ì¼€ì¼ë§ìœ¼ë¡œ ê°€ëŠ¥í•œ íŒ¨í„´ë“¤  

Consider a scenario where you are running a major sales campaign, the biggest marketing campaign you have ever done.  
ì˜ˆë¥¼ ë“¤ì–´, ê°€ì¥ í° ë§ˆì¼€íŒ… ìº í˜ì¸ì¸ ëŒ€ê·œëª¨ ì„¸ì¼ ìº í˜ì¸ì„ ì§„í–‰í•œë‹¤ê³  ê°€ì •í•©ì‹œë‹¤.  

All your customers will place orders, which need to be stored in databases.  
ëª¨ë“  ê³ ê°ë“¤ì´ ì£¼ë¬¸ì„ ë„£ìœ¼ë©°, ì´ ì£¼ë¬¸ì€ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.  

These databases could be Amazon RDS or Amazon Aurora for OLTP workloads, or Amazon DynamoDB if you prefer a NoSQL database.  
ë°ì´í„°ë² ì´ìŠ¤ëŠ” OLTP ì›Œí¬ë¡œë“œì— ì í•©í•œ Amazon RDS ë˜ëŠ” Amazon Auroraì¼ ìˆ˜ ìˆê³ , NoSQL ë°ì´í„°ë² ì´ìŠ¤ê°€ í•„ìš”í•˜ë‹¤ë©´ Amazon DynamoDBì¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.  

During sudden spikes, transactions may be written very quickly into these databases.  
ê°‘ì‘ìŠ¤ëŸ¬ìš´ íŠ¸ë˜í”½ ê¸‰ì¦ ì‹œ, íŠ¸ëœì­ì…˜ì´ ë§¤ìš° ë¹ ë¥´ê²Œ ë°ì´í„°ë² ì´ìŠ¤ì— ê¸°ë¡ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

Your application can handle requests, but if the databases become overloaded, errors may occur, causing loss of customer transactions, which is detrimental to your business.  
ì• í”Œë¦¬ì¼€ì´ì…˜ì€ ìš”ì²­ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆì§€ë§Œ ë°ì´í„°ë² ì´ìŠ¤ê°€ ê³¼ë¶€í•˜ë˜ë©´ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì—¬ ê³ ê° íŠ¸ëœì­ì…˜ì´ ì†ì‹¤ë  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ì— ì¹˜ëª…ì ì…ë‹ˆë‹¤.  

---

## Using SQS as a Buffer for Database Writes  
## ë°ì´í„°ë² ì´ìŠ¤ ì“°ê¸°ë¥¼ ìœ„í•œ ë²„í¼ë¡œì„œì˜ SQS  

To solve this problem, we can use SQS as a buffer for database writes.  
ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ SQSë¥¼ ë°ì´í„°ë² ì´ìŠ¤ ì“°ê¸°ì˜ ë²„í¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

This is a common exam pattern.  
ì´ëŠ” ì‹œí—˜ì—ì„œ ìì£¼ ë“±ì¥í•˜ëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.  

Instead of writing transactions directly into the database, the application writes transaction requests into the SQS queue.  
íŠ¸ëœì­ì…˜ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì§ì ‘ ê¸°ë¡í•˜ëŠ” ëŒ€ì‹ , ì• í”Œë¦¬ì¼€ì´ì…˜ì€ íŠ¸ëœì­ì…˜ ìš”ì²­ì„ SQS íì— ê¸°ë¡í•©ë‹ˆë‹¤.  

AWS defines SQS as infinitely scalable and free from throughput issues.  
AWSëŠ” SQSë¥¼ **ë¬´í•œ í™•ì¥ ê°€ëŠ¥í•˜ë©° ì²˜ë¦¬ëŸ‰ ë¬¸ì œì—ì„œ ììœ ë¡œìš´ ì„œë¹„ìŠ¤**ë¡œ ì •ì˜í•©ë‹ˆë‹¤.  

The requests enter your application and are enqueued as messages in the SQS queue.  
ìš”ì²­ì€ ì• í”Œë¦¬ì¼€ì´ì…˜ì— ë“¤ì–´ì™€ SQS íì— ë©”ì‹œì§€ë¡œ ì €ì¥ë©ë‹ˆë‹¤.  

This guarantees that no transaction is lost, as all messages are durably stored in the queue.  
ëª¨ë“  ë©”ì‹œì§€ê°€ íì— ë‚´êµ¬ì„± ìˆê²Œ ì €ì¥ë˜ë¯€ë¡œ, íŠ¸ëœì­ì…˜ì´ ì†ì‹¤ë˜ì§€ ì•ŠìŒì„ ë³´ì¥í•©ë‹ˆë‹¤.  

We can create another Auto Scaling Group whose sole role is to dequeue messages and insert them into the databases.  
ë©”ì‹œì§€ë¥¼ íì—ì„œ êº¼ë‚´ ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…í•˜ëŠ” ì „ìš© ì˜¤í†  ìŠ¤ì¼€ì¼ë§ ê·¸ë£¹ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

Only when a message is confirmed to be inserted into the database do we delete it from the original SQS queue.  
ë©”ì‹œì§€ê°€ ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…ë˜ì—ˆìŒì´ í™•ì¸ë  ë•Œë§Œ ì›ë˜ SQS íì—ì„œ í•´ë‹¹ ë©”ì‹œì§€ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.  

This pattern ensures every transaction is eventually written to the database.  
ì´ íŒ¨í„´ì€ ëª¨ë“  íŠ¸ëœì­ì…˜ì´ ê²°êµ­ ë°ì´í„°ë² ì´ìŠ¤ì— ê¸°ë¡ë˜ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤.  

This pattern works well if the client does not require immediate confirmation that the write has occurred in the database.  
í´ë¼ì´ì–¸íŠ¸ê°€ ë°ì´í„°ë² ì´ìŠ¤ì— ì“°ê¸°ê°€ ì¦‰ì‹œ ì™„ë£Œë˜ì—ˆë‹¤ëŠ” í™•ì¸ì„ ìš”êµ¬í•˜ì§€ ì•Šì„ ë•Œ ì´ íŒ¨í„´ì´ ì˜ ì‘ë™í•©ë‹ˆë‹¤.  

Since the write to the SQS queue guarantees eventual database insertion, this approach provides reliability and decouples the application from the database write latency.  
SQS íì— ê¸°ë¡ëœ ë©”ì‹œì§€ëŠ” ê²°êµ­ ë°ì´í„°ë² ì´ìŠ¤ì— ì‚½ì…ë˜ë¯€ë¡œ, ì´ ì ‘ê·¼ë²•ì€ ì‹ ë¢°ì„±ì„ ë³´ì¥í•˜ë©° ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë°ì´í„°ë² ì´ìŠ¤ ì“°ê¸° ì§€ì—°ìœ¼ë¡œë¶€í„° ë¶„ë¦¬í•©ë‹ˆë‹¤.  

---

## Decoupling Application Tiers with SQS  
## SQSë¥¼ í†µí•œ ì• í”Œë¦¬ì¼€ì´ì…˜ ê³„ì¸µ ë¶„ë¦¬  

SQS also enables decoupling between application tiers.  
SQSëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ ê³„ì¸µ ê°„ì˜ ë¶„ë¦¬ë„ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.  

For example, an application might receive a request, perform some processing, and send back a response.  
ì˜ˆë¥¼ ë“¤ì–´, ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ìš”ì²­ì„ ë°›ê³  ì¼ë¶€ ì²˜ë¦¬ë¥¼ ìˆ˜í–‰í•œ ë’¤ ì‘ë‹µì„ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

Instead, you can decouple this by having all requests come into a front-end web application, which sends the requests into an SQS queue.  
ëŒ€ì‹  ëª¨ë“  ìš”ì²­ì„ í”„ëŸ°íŠ¸ì—”ë“œ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ë°›ì•„ì„œ ì´ë¥¼ SQS íì— ë„£ë„ë¡ í•˜ì—¬ ê³„ì¸µì„ ë¶„ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

The backend processing jobs then receive these messages and handle them asynchronously at their own pace.  
ë°±ì—”ë“œ ì²˜ë¦¬ ì‘ì—…ì€ ì´ ë©”ì‹œì§€ë¥¼ ë°›ì•„ ë¹„ë™ê¸°ì ìœ¼ë¡œ ìì²´ ì†ë„ì— ë§ê²Œ ì²˜ë¦¬í•©ë‹ˆë‹¤.  

This setup allows you to scale the backend processing independently and efficiently.  
ì´ ë°©ì‹ì€ ë°±ì—”ë“œ ì²˜ë¦¬ë¥¼ ë…ë¦½ì ì´ê³  íš¨ìœ¨ì ìœ¼ë¡œ í™•ì¥í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.  

---

## Conclusion  
## ê²°ë¡   

SQS is a very common and powerful tool for handling decoupling, sudden spikes in load, timeouts, and scaling requirements.  
SQSëŠ” ê³„ì¸µ ë¶„ë¦¬, ê°‘ì‘ìŠ¤ëŸ¬ìš´ ë¶€í•˜ ì¦ê°€, íƒ€ì„ì•„ì›ƒ, ìŠ¤ì¼€ì¼ë§ ìš”êµ¬ ì‚¬í•­ì„ ì²˜ë¦¬í•˜ëŠ” ë° ë§¤ìš° ì¼ë°˜ì ì´ê³  ê°•ë ¥í•œ ë„êµ¬ì…ë‹ˆë‹¤.  

When you need to scale quickly and reliably, especially in exam scenarios, consider using an SQS queue.  
ë¹ ë¥´ê³  ì•ˆì •ì ìœ¼ë¡œ í™•ì¥ì´ í•„ìš”í•  ë•Œ, íŠ¹íˆ ì‹œí—˜ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ, SQS í ì‚¬ìš©ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤.  

---

## Key Takeaways  
## í•µì‹¬ ìš”ì•½  

SQS queues can be integrated with Auto Scaling Groups to automatically scale EC2 instances based on queue size.  
SQS íëŠ” ì˜¤í†  ìŠ¤ì¼€ì¼ë§ ê·¸ë£¹ê³¼ í†µí•©ë˜ì–´ í í¬ê¸°ì— ë”°ë¼ EC2 ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìë™ìœ¼ë¡œ í™•ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

CloudWatch metrics like approximate number of messages in the queue can trigger alarms to scale resources up or down.  
CloudWatch ì§€í‘œ(í ë‚´ ëŒ€ëµì ì¸ ë©”ì‹œì§€ ìˆ˜ ë“±)ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì•ŒëŒì„ íŠ¸ë¦¬ê±°í•˜ì—¬ ë¦¬ì†ŒìŠ¤ë¥¼ í™•ì¥í•˜ê±°ë‚˜ ì¶•ì†Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

Using SQS as a buffer between applications and databases prevents data loss during high transaction loads.  
SQSë¥¼ ì• í”Œë¦¬ì¼€ì´ì…˜ê³¼ ë°ì´í„°ë² ì´ìŠ¤ ì‚¬ì´ì˜ ë²„í¼ë¡œ ì‚¬ìš©í•˜ë©´ ë†’ì€ íŠ¸ëœì­ì…˜ ë¶€í•˜ ì¤‘ì—ë„ ë°ì´í„° ì†ì‹¤ì„ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

Decoupling application tiers with SQS allows for scalable, asynchronous processing of requests.  
SQSë¥¼ í†µí•œ ì• í”Œë¦¬ì¼€ì´ì…˜ ê³„ì¸µ ë¶„ë¦¬ëŠ” ìš”ì²­ì˜ í™•ì¥ ê°€ëŠ¥í•˜ê³  ë¹„ë™ê¸°ì ì¸ ì²˜ë¦¬ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤. 
