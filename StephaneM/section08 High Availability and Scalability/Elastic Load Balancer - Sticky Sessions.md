# Elastic Load Balancer - Sticky Sessions  
# 엘라스틱 로드 밸런서 - 스티키 세션  
(ELB에서 스티키 세션, 즉 세션 친화성에 대해 설명하는 내용)

---

## Sticky Sessions (Session Affinity) in Elastic Load Balancer  
## 스티키 세션(세션 친화성) in 엘라스틱 로드 밸런서  
(스티키 세션은 여러 요청을 같은 인스턴스로 고정 라우팅하는 기능)

Let's discuss sticky sessions, also known as session affinity, for your Elastic Load Balancer (ELB). Sticky sessions allow a client making multiple requests to the load balancer to be routed to the same backend instance consistently.  
엘라스틱 로드 밸런서에서 스티키 세션(세션 친화성)을 살펴봅시다. 스티키 세션은 클라이언트가 여러 요청을 보낼 때 동일한 백엔드 인스턴스로 계속 라우팅되도록 합니다.  
(즉, 같은 사용자가 보낸 요청은 계속 같은 서버로 보냄)

---

For example, consider an Application Load Balancer (ALB) with two EC2 instances and three clients. If client one sends a request that routes to the first EC2 instance, then any subsequent requests from client one to the load balancer will also be routed to that same instance. This behavior differs from the usual load balancer behavior, which distributes requests evenly across all EC2 instances.  
예를 들어, ALB에 두 개의 EC2 인스턴스와 세 명의 클라이언트가 있다고 합시다. 클라이언트 1이 첫 번째 인스턴스로 요청을 보내면, 이후 요청도 계속 같은 인스턴스로 라우팅됩니다. 이는 기본적인 로드 밸런서의 "균등 분배" 동작과 다릅니다.  
(보통은 분산되지만, 스티키 세션은 특정 서버에 고정됨)

---

Similarly, client two's requests will consistently go to the second instance, and the same applies for client three.  
마찬가지로 클라이언트 2는 두 번째 인스턴스로 고정되고, 클라이언트 3도 동일한 방식으로 처리됩니다.  
(각 사용자마다 고정된 인스턴스로 연결됨)

---

Sticky sessions can be enabled on Classic Load Balancer (CLB), Application Load Balancer (ALB), and Network Load Balancer (NLB). The mechanism relies on a cookie sent as part of the client's request to the load balancer. This cookie contains stickiness information and an expiration date. When the cookie expires, the client may be routed to a different EC2 instance.  
스티키 세션은 CLB, ALB, NLB에서 모두 활성화할 수 있습니다. 이 기능은 쿠키를 기반으로 동작하며, 쿠키에는 고정 정보와 만료 시간이 포함됩니다. 쿠키가 만료되면 다른 인스턴스로 라우팅될 수도 있습니다.  
(쿠키를 통해 세션 고정을 관리함)

---

The primary use case for sticky sessions is to ensure that a user remains connected to the same backend instance to preserve session data, such as login information. However, enabling stickiness can cause load imbalance across backend instances if some users are highly sticky to specific instances.  
스티키 세션의 주요 목적은 로그인 정보 같은 세션 데이터를 유지하기 위해 사용자를 동일한 인스턴스에 연결시키는 것입니다. 하지만 일부 사용자가 특정 인스턴스에 몰리면 부하 불균형이 생길 수 있습니다.  
(장점은 세션 유지, 단점은 부하 불균형)

---

## Types of Cookies for Sticky Sessions  
## 스티키 세션에 사용되는 쿠키 유형  
(쿠키 종류는 2가지)

There are two types of cookies used for sticky sessions:  
스티키 세션에 사용되는 쿠키는 두 가지입니다.  

- Application-based cookies  
- 애플리케이션 기반 쿠키  

- Duration-based cookies  
- 기간 기반 쿠키  

---

### Application-Based Cookies  
### 애플리케이션 기반 쿠키  

These are custom cookies generated by the target application itself. You can include any custom attributes required by your application. The cookie name must be specified individually for each target group.  
이 쿠키는 애플리케이션이 직접 생성하는 쿠키입니다. 필요한 속성을 자유롭게 지정할 수 있으며, 쿠키 이름은 각 타겟 그룹마다 따로 설정해야 합니다.  
(앱이 직접 만든 쿠키)

Note that you must not use the following reserved cookie names: AWSALB, AWSALBAPPOR, or AWSALBTG, as these are reserved for use by the Elastic Load Balancer itself.  
단, AWSALB, AWSALBAPPOR, AWSALBTG는 ELB 전용으로 예약된 이름이므로 사용해서는 안 됩니다.  
(특정 예약어는 금지됨)

---

### Duration-Based Cookies  
### 기간 기반 쿠키  

These cookies are generated by the load balancer itself. For the Application Load Balancer, the cookie name is AWSALB, and for the Classic Load Balancer, it is AWSELB. The cookie has an expiration based on a specific duration set by the load balancer.  
이 쿠키는 로드 밸런서가 직접 생성합니다. ALB에서는 AWSALB, CLB에서는 AWSELB라는 이름을 가집니다. 만료 시간은 로드 밸런서가 설정한 기간에 따라 달라집니다.  
(로드 밸런서 자체 생성 쿠키)

In contrast, with application-based cookies, the duration can be specified by the application itself.  
반대로 애플리케이션 기반 쿠키는 만료 시간을 애플리케이션이 직접 지정할 수 있습니다.  
(앱 쿠키 = 앱이 만료 설정)

---

## Summary of Cookie Types  
## 쿠키 유형 요약  

- Application-based cookies: Custom cookies generated by the application with user-defined attributes and names.  
- 애플리케이션 기반 쿠키: 애플리케이션이 직접 생성하며, 속성과 이름을 자유롭게 지정 가능.  

- Duration-based cookies: Load balancer-generated cookies with a fixed expiration duration.  
- 기간 기반 쿠키: 로드 밸런서가 생성하며, 만료 기간은 고정.  

These cookie types and their names are important considerations when configuring sticky sessions and will also be relevant when discussing CloudFront.  
이 쿠키의 종류와 이름은 스티키 세션 설정 시 중요하며, CloudFront와 연계할 때도 중요합니다.  
(쿠키 종류 이해는 필수)

---

## Enabling Sticky Sessions on Target Groups  
## 타겟 그룹에서 스티키 세션 활성화  

To enable sticky sessions, navigate to your target group in the AWS Management Console. Under the "Actions" menu, select "Edit attributes." Scroll down to the "Target group stickiness" section.  
스티키 세션을 켜려면 AWS 콘솔에서 타겟 그룹으로 이동 → Actions → Edit attributes → Target group stickiness 항목으로 내려갑니다.  
(콘솔에서 설정 가능)

Here, you can enable stickiness and choose between two types:  
여기서 스티키 세션을 활성화하고 쿠키 유형을 선택할 수 있습니다.  

- Load balancer-generated cookie  
- 로드 밸런서 생성 쿠키  

- Application-based cookie  
- 애플리케이션 기반 쿠키  

For the load balancer-generated cookie, you can set the duration between one second and seven days. For application-based cookies, you must specify the cookie name, for example, MYCUSTOMCOOKIEAPP.  
로드 밸런서 생성 쿠키는 1초 ~ 7일 범위에서 만료 시간을 설정할 수 있고, 애플리케이션 쿠키는 쿠키 이름을 반드시 지정해야 합니다 (예: MYCUSTOMCOOKIEAPP).  
(로드밸런서 쿠키 = 기간 설정 / 앱 쿠키 = 이름 지정)

To keep things simple, you can select the load balancer-generated cookie with the default duration of one day and save the changes.  
간단하게는 로드 밸런서 생성 쿠키를 하루짜리 기본값으로 선택하고 저장하면 됩니다.  
(기본 설정: 1일)

---

## Observing Sticky Sessions in Action  
## 스티키 세션 동작 관찰하기  

After enabling sticky sessions, you can observe the behavior using your browser's developer tools. Open the network tab and refresh the page multiple times. You will notice that the requests consistently reach the same backend instance.  
스티키 세션을 활성화한 뒤, 브라우저 개발자 도구 → 네트워크 탭에서 페이지를 여러 번 새로고침해 보세요. 요청이 항상 같은 인스턴스로 가는 것을 확인할 수 있습니다.  
(개발자 도구로 확인 가능)

Inspecting the request and response headers, you will see a cookie set by the load balancer with an expiration date. This cookie is sent back with each request, enabling the load balancer to route the client to the same instance.  
요청/응답 헤더를 보면, 로드 밸런서가 쿠키를 설정한 것을 확인할 수 있습니다. 이 쿠키가 요청마다 전송되어 동일한 인스턴스로 라우팅됩니다.  
(헤더에서 쿠키 확인 가능)

---

## Disabling Sticky Sessions  
## 스티키 세션 비활성화  

If you want to revert to the default load balancing behavior without stickiness, you can disable sticky sessions by editing the target group attributes and turning off stickiness. This will allow the load balancer to distribute requests evenly across all backend instances.  
스티키 세션을 끄고 싶다면 타겟 그룹 속성에서 stickiness 옵션을 비활성화하면 됩니다. 그러면 요청이 모든 인스턴스에 균등하게 분배됩니다.  
(기본 라운드 로빈 방식으로 돌아감)

---

## This concludes the lecture on sticky sessions. I hope you found it informative.  
## 스티키 세션 강의는 여기까지입니다. 도움이 되었길 바랍니다.  

---

## Key Takeaways  
## 핵심 요약  

- Sticky sessions, or session affinity, ensure that a client consistently connects to the same backend instance through the load balancer.  
- 스티키 세션은 특정 클라이언트가 항상 동일한 인스턴스에 연결되도록 합니다.  

- Sticky sessions can be enabled on Classic Load Balancer, Application Load Balancer, and Network Load Balancer using cookies.  
- CLB, ALB, NLB 모두 쿠키를 이용해 스티키 세션을 활성화할 수 있습니다.  

- There are two types of cookies for stickiness: application-based cookies generated by the target application, and duration-based cookies generated by the load balancer.  
- 스티키 세션 쿠키는 애플리케이션 기반 쿠키와 로드 밸런서 생성 쿠키 두 가지가 있습니다.  

- Enabling stickiness may cause load imbalance if some users are very sticky to specific backend instances.  
- 특정 인스턴스에 사용자가 몰리면 부하 불균형이 생길 수 있습니다.  

---
